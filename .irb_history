first_name = "M"
"#{first_name} H"
puts "foo"
puts first_name
city = "大牟田市"
prefecture = "福岡県"
puts "#{prefecture} #{city}"
puts "#{prefecture} \t #{city}"
puts '\#{prefecture} \\t #{city}'
puts '\#{prefecture} \t #{city}'
puts "#{prefecture}"+"\t"+"#{city}"
puts "#{prefecture}"+'\\t'+"#{city}"
puts "#{prefecture}"+'\\\t'+"#{city}"
puts "#{prefecture}"+'\t'+"#{city}"
puts "#{prefecture}"+'t'+"#{city}"
puts "#{prefecture}"+"\t"+"#{city}"
puts "#{prefecture}"+'\\t'+"#{city}"
"rececar".length
"rececar".re
s = "rececar"
if s == s.reverse\
  puts true\
else\
  puts false\
end
s = "onomatopoeia"
puts "It's a palindrome!" if s == s.reverse
exit
def oalindrome_tester(s)\
  if s == s.reverse\
    puts "It's a palindorome!"\
  else\
    puts "It's a not a palindrome."\
  end\
end
oalin
o
oalindrome_tester("racecar")
oalindrome_tester("onomatopoeia")
oalindrome_tester("onomatopoeia").nil?
exit
a = "A man, a plan, a canal, Panama"
s = a
a = s.split(", ")
s = a.join
s.split(" ").join
def oalindrome_tester(s)\
  if s == s.reverse\
    puts "It's palindorome!"\
  else\
    puts "It's not palindorome"\
  end\
end
s.split(" ").join!
s.split(" ").join
s = s.split(" ").join
oalindrome_tester(s)
oalindrome_tester(s.downcase)
s.downcase
oalindrome_tester(s.downcase!)
puts s
(a..z).to_a[7]
(a..z).to_a
("a".."z").to_a
("a".."z").to_a[7]
("a".."z").to_a[-7]
def yeller(a)\
  s = a.join.upcase\
  puts s\
end
yeller(['o', 'l', 'd'])
def yeller(a)\
  a.map{ |c| c.upcase }\
end
yeller(['o', 'l', 'd'])
def yeller(a)\
  a.map{ |c| c.upcase }.join\
end
yeller(['o', 'l', 'd'])
def sguffled_subdomain(s="")\
  s = s.to_a.shuffle[0..7].join\
end
def string_shuffle(s="")\
  s = s.to_a.shuffle[0..7].join\
end
string_shuffle("foobar")
def string_shuffle(s="")\
  s = s.slit("").shuffle.join\
end
string_shuffle("foobar")
def string_shuffle(s="")\
  s = s.split("").shuffle.join\
end
string_shuffle("foobar")
a = {:one=>"uno",:two=>"dos",:three=>"tres"}
a.each do |key,value|\
  puts "#{key} #{value}"\
end
person1 = {}
person2 = {}
person3 = {}
person1
person1[:first] = "a"
person1[:last] = "z"
person2[:last] = "z2"
person3[:last] = "z3"
person2[:first] = "a2"
person3[:first] = "a3"
params = {}
params[:father] = person1
params[:mother] = person2
params[:child] = person3
params[:father][:first]
 { "a" => 100, "b" => 200 }.merge({ "b" => 300 })
Range.suoerClass
Range.superClass
Range.superclass
Range.superclass.superclass
Hash.superclass.superclass
Hash.superclass
Symbol.superclass
self == reverse
self == self.reverse
exit
val = 1
if "#{val}".blank?\
  puts "a"\
else\
  puts "aa"\
end
def tesa"\
  else\
    puts "aa"\
  end\
end
val = nil
test(val)
test("#{val}")
def test(s)\
  if "#{s}".blank?\
    puts "a"\
  else\
    puts "aa"\
  end\
end
val = nil
test(val)
val = ""
test(val)
val = 1
test(val)
exit
user = User.new
user.superclass
User.superclass
User.superclass.superclass
exit
User.new
exit
User.first
user = User.first
user.destroy
puts user
exit
user = User.new(:name=>"aaa",:email=>"bbb")

user = User.create(:name=>"aaa",:email=>"bbb")
user.name.superclass
User.first
name = User.first.name
name.superclass
User.name.superclass
User.superclass
a = "aaa"
a.superclass
user.name
User.name.is_a?(String)
User.created_at.is_a?
User.created_at.class
user.creates
user.created_At
user.created_at
user.created_at.class
User.find(1)
User.find_by_name("aaa")
User.all.class
User.all.length
puts user
user.email
user.email = "ccc"
user.reload.email
exit
user = User.new(name:"",email:"aa@samole.com")
user.valid?
user.errors.full_messages
user.save
exit
user = User.new(:name=>"test",:email=>"sample@text.com")
user.name = "11111111111111111111111111111111111111111111111111111111111111111111111111111"
user.save
user.errors.full_messages
exit
user = User.first
user.created_at.class
user.name.class
exit
users = User.all
users.class
ary = [1,2,3]
ary.class
users.length
exit
user = User.create(name: "Example User", email: "user@example.com")
user.email.upcase
duplicate_user = user.dup
dublocate_user.email = user.email.upcase
duplicate_user.email = user.email.upcase
duplicate_user.valid?
exit
user = User.new(:name=>"foo",:email=>"sample@text.com")
user.save
user.valid?
user.errors.full_message
user.errors.full_messages
exit
user = User.new(:name=>"foo",:email=>"test@samp.com",:password=>"a",:password_confirmation=>"a")
user.valid?
user.errors.full_messages
User.create(name:"Michael H",email:"michael@example.com",)
User.create(name:"Michael H",email:"michael@example.com",password:"foobar",password_confimation:"foobar")
User.create(name:"Michael H",email:"michael@example.com",password:"foobar",password_confirmation:"foobar")
user = User.find_by(email: "michael@example.com")
user.password_digest
user.authenticate("not_sss")
user.authenticate("foobaz")
user.authenticate("foobar")
!!user.authenticate("foobar")
exit
user = User.find_by(email:"michael@example.com")
user.name = "test"
user.save
user.name = "test"
user.reload.name
user.save
user.a
user.name = "test"
user.valid?
user.errors.full_messages
user.autheticate("foobar")
user.authenticate("foobar")
user.name = "test"
user.save
user.update(name:"test",password:"foobar",password_confirmation:"foobar")
user = User.find_by(email:"michael@example.com")
user.name
exit
user = User.first
user.update(name:"Example User",email:"example@railstutorial.org",password:"foobar",password_confirmation:"foobar")
exit
user.errors.count
exit
User.all
exit
"#{:success}"
flash = { success: "It worked!", danger: "It failed." }
flash.each do |key, value|\
  puts "#{key}"\
  puts "#{value}"\
end
exit
user = User.first
user.email
exit
user = User.first
user = nil
if user && user.authenticate('aaa')\
end
user && user.authenticate('aaa')
user = User.first
user && user.authenticate('aaa')
user && user.authenticate('foobar')
!!(user && user.authenticate('foobar'))
!(user && user.authenticate('foobar'))
val = 1
!!(val==1)
(val==1)
!(val==1)
!(val)
val
!!(val)
!!(val.empty?)
!!(val.empty)
exit
pass = ""
pass.downcase
wzir
exit
user = User.first
user.email
User.find_by(id: 3)
sessions = {}
s
session = {}
session[:user_id] = nil
@current_user ||= User.find_by(id: session[:user_id])
session[:user_id] = User.first.id
@current_user ||= User.find_by(id: session[:user_id])
@current_user ||= User.find_by(id: session[:user_id])
exit
user = User.first
user.remenber
user.remenber_token
user =User.first
user
user.remember?
self.remember_token = User.new_token
user.remember_token = User.new_token
update_attribute(:remember_digest, User.digest(remember_token))
update_attribute(:remember_digest, User.digest(user.remember_token))
user.remember_token = User.new_token
update_attribute(:remember_digest, User.digest(user.remember_token))
exit
user = User.first
assigns(user)
exit
User.new.new_record?
User.first.new_record?
exit
users = User.all
users.superclass
users = User.paginate(page:1)
users.superclass
users.class
users = User.all
users.class
User.paginate(page:nil)
users = User.paginate(page:nil)
users.class
users = User.all
users.class
paginate.class
users = User.paginate(page:nil)
users.su
users.superclass
users.superclass.superclass
users.superclass.superclass.superClass
users = User.all
users.superclass.superclass
exit
user = User.first
user.admin?
user.toggle!(:admin)
user.admin?
exit
user = User.first
user.remenber_token
user.remenber_token=\
?\
exit
user.session_token
exit
user = User.first
user.create_activation_digest
exit
CGI.escape('foo@example.com')
CGI.escape("Don't panic!")
exit
user = User.find_by(name:"test")
user.activated
exit
user = User.new(name: "ttt",email:"ttt@sample.com",password:"password",password_confirmation: "password",admin:true)
user.save
user.activate
user.remember_token
user.remember_digest
user.activation_token
user.activation_digest
exit
user = User.find_by(name:"test")
user.activation
user.activated
user.activated
user = User.find_by(name:"test")
user.activated
exit
user = User.first
user.email
user.reset_digest
user.reset_sent_at
user = User.first
user.reset_sent_at
user.reset_digest
user = User.first
user.reset_digest
user.reset_sent_at
exit
user = User.first
user.password_digest
user.password_digest
user = User.first
user.password_digest
exit
micropost = Micropost.new
Micropost.new
micropost = Micropost.new
exit
User.new
Mi
Micropost.new
Microposts.new
exit
micropost = Micropost.new
user = user.first
user = User.first
exit
User.new
Micropost.new
micropost = Micropot.new
micropost = Micropost.new
user = User.first
micropost.user_id = uesr.id
micropost.user_id = user.id
micropost.created_at
micropost.user
micropost.user.name
micropost.save
micropost.user.name
micropost.created_at
exit
micropost = Micropost.new(user_id:nil,content:"")
micropost.invalid?
micropost = Micropost.new
micropost.invalid?
exit
micropost = Micropost.new
micropost.user_id
micropost.invalid?
micropost.valid?
micropost.errors.full_messages
exit
user = User.first
micropost = user.microposts.create(content:"Lorem ipsum")
user.microposts.find(micropost.id)
user.microposts.find(micropost)
user == micropost.user
user.microposts.first == micropost
exit
Micropost.first.created_at
Micropost.last.created_at
Micropost.first
Micropost.last
exit
helper.time_ago_in_words(3.wooks.ago)
helper.time_ago_in_words(3.works.ago)
helper.time_ago_in_words(3.weeks.ago)
helper.time_ago_in_words(6.months.ago)
helper.time_ago_in_words(1.years.ago)
user = User.first
microposts = user.microposts.paginates(page:nil)
microposts = user.microposts.pagenates(page:nil)
microposts = user.microposts.paginate(page: nil)
microposts.class
exit
user = User.first
Micropost.where("user_id=?",user.id)
Micropost.where("user_id=?",user.id) == user.microposts
Micropost.where("user_id=?",user.id) == user.feed
user.microposts = user.feed
user.feed
user.microposts
user = User.first
user.feed == user.microposts
exit
exit
exit
user = User.first
user.active_relationships.create!(followed_id: 2)
active_relationship.followed
user.active_relationship.followed
exit
user = User.first
user2 = User.find(2)
user.follow(user2)
user.unfollow(user2)
user.follow(user2)
exit
User.first.followers.count
User.first.following.count
exit
