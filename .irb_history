first_name = "M"
"#{first_name} H"
puts "foo"
puts first_name
city = "大牟田市"
prefecture = "福岡県"
puts "#{prefecture} #{city}"
puts "#{prefecture} \t #{city}"
puts '\#{prefecture} \\t #{city}'
puts '\#{prefecture} \t #{city}'
puts "#{prefecture}"+"\t"+"#{city}"
puts "#{prefecture}"+'\\t'+"#{city}"
puts "#{prefecture}"+'\\\t'+"#{city}"
puts "#{prefecture}"+'\t'+"#{city}"
puts "#{prefecture}"+'t'+"#{city}"
puts "#{prefecture}"+"\t"+"#{city}"
puts "#{prefecture}"+'\\t'+"#{city}"
"rececar".length
"rececar".re
s = "rececar"
if s == s.reverse\
  puts true\
else\
  puts false\
end
s = "onomatopoeia"
puts "It's a palindrome!" if s == s.reverse
exit
def oalindrome_tester(s)\
  if s == s.reverse\
    puts "It's a palindorome!"\
  else\
    puts "It's a not a palindrome."\
  end\
end
oalin
o
oalindrome_tester("racecar")
oalindrome_tester("onomatopoeia")
oalindrome_tester("onomatopoeia").nil?
exit
a = "A man, a plan, a canal, Panama"
s = a
a = s.split(", ")
s = a.join
s.split(" ").join
def oalindrome_tester(s)\
  if s == s.reverse\
    puts "It's palindorome!"\
  else\
    puts "It's not palindorome"\
  end\
end
s.split(" ").join!
s.split(" ").join
s = s.split(" ").join
oalindrome_tester(s)
oalindrome_tester(s.downcase)
s.downcase
oalindrome_tester(s.downcase!)
puts s
(a..z).to_a[7]
(a..z).to_a
("a".."z").to_a
("a".."z").to_a[7]
("a".."z").to_a[-7]
def yeller(a)\
  s = a.join.upcase\
  puts s\
end
yeller(['o', 'l', 'd'])
def yeller(a)\
  a.map{ |c| c.upcase }\
end
yeller(['o', 'l', 'd'])
def yeller(a)\
  a.map{ |c| c.upcase }.join\
end
yeller(['o', 'l', 'd'])
def sguffled_subdomain(s="")\
  s = s.to_a.shuffle[0..7].join\
end
def string_shuffle(s="")\
  s = s.to_a.shuffle[0..7].join\
end
string_shuffle("foobar")
def string_shuffle(s="")\
  s = s.slit("").shuffle.join\
end
string_shuffle("foobar")
def string_shuffle(s="")\
  s = s.split("").shuffle.join\
end
string_shuffle("foobar")
a = {:one=>"uno",:two=>"dos",:three=>"tres"}
a.each do |key,value|\
  puts "#{key} #{value}"\
end
person1 = {}
person2 = {}
person3 = {}
person1
person1[:first] = "a"
person1[:last] = "z"
person2[:last] = "z2"
person3[:last] = "z3"
person2[:first] = "a2"
person3[:first] = "a3"
params = {}
params[:father] = person1
params[:mother] = person2
params[:child] = person3
params[:father][:first]
 { "a" => 100, "b" => 200 }.merge({ "b" => 300 })
Range.suoerClass
Range.superClass
Range.superclass
Range.superclass.superclass
Hash.superclass.superclass
Hash.superclass
Symbol.superclass
self == reverse
self == self.reverse
exit
val = 1
if "#{val}".blank?\
  puts "a"\
else\
  puts "aa"\
end
def tesa"\
  else\
    puts "aa"\
  end\
end
val = nil
test(val)
test("#{val}")
def test(s)\
  if "#{s}".blank?\
    puts "a"\
  else\
    puts "aa"\
  end\
end
val = nil
test(val)
val = ""
test(val)
val = 1
test(val)
exit
user = User.new
user.superclass
User.superclass
User.superclass.superclass
exit
User.new
exit
User.first
user = User.first
user.destroy
puts user
exit
user = User.new(:name=>"aaa",:email=>"bbb")

user = User.create(:name=>"aaa",:email=>"bbb")
user.name.superclass
User.first
name = User.first.name
name.superclass
User.name.superclass
User.superclass
a = "aaa"
a.superclass
user.name
User.name.is_a?(String)
User.created_at.is_a?
User.created_at.class
user.creates
user.created_At
user.created_at
user.created_at.class
User.find(1)
User.find_by_name("aaa")
User.all.class
User.all.length
puts user
user.email
user.email = "ccc"
user.reload.email
exit
user = User.new(name:"",email:"aa@samole.com")
user.valid?
user.errors.full_messages
user.save
exit
user = User.new(:name=>"test",:email=>"sample@text.com")
user.name = "11111111111111111111111111111111111111111111111111111111111111111111111111111"
user.save
user.errors.full_messages
exit
user = User.first
user.created_at.class
user.name.class
exit
users = User.all
users.class
ary = [1,2,3]
ary.class
users.length
exit
user = User.create(name: "Example User", email: "user@example.com")
user.email.upcase
duplicate_user = user.dup
dublocate_user.email = user.email.upcase
duplicate_user.email = user.email.upcase
duplicate_user.valid?
exit
user = User.new(:name=>"foo",:email=>"sample@text.com")
user.save
user.valid?
user.errors.full_message
user.errors.full_messages
exit
user = User.new(:name=>"foo",:email=>"test@samp.com",:password=>"a",:password_confirmation=>"a")
user.valid?
user.errors.full_messages
User.create(name:"Michael H",email:"michael@example.com",)
User.create(name:"Michael H",email:"michael@example.com",password:"foobar",password_confimation:"foobar")
User.create(name:"Michael H",email:"michael@example.com",password:"foobar",password_confirmation:"foobar")
user = User.find_by(email: "michael@example.com")
user.password_digest
user.authenticate("not_sss")
user.authenticate("foobaz")
user.authenticate("foobar")
!!user.authenticate("foobar")
exit
user = User.find_by(email:"michael@example.com")
user.name = "test"
user.save
user.name = "test"
user.reload.name
user.save
user.a
user.name = "test"
user.valid?
user.errors.full_messages
user.autheticate("foobar")
user.authenticate("foobar")
user.name = "test"
user.save
user.update(name:"test",password:"foobar",password_confirmation:"foobar")
user = User.find_by(email:"michael@example.com")
user.name
exit
user = User.first
user.update(name:"Example User",email:"example@railstutorial.org",password:"foobar",password_confirmation:"foobar")
exit
user.errors.count
exit
User.all
exit
"#{:success}"
flash = { success: "It worked!", danger: "It failed." }
flash.each do |key, value|\
  puts "#{key}"\
  puts "#{value}"\
end
exit
user = User.first
user.email
exit
user = User.first
user = nil
if user && user.authenticate('aaa')\
end
user && user.authenticate('aaa')
user = User.first
user && user.authenticate('aaa')
user && user.authenticate('foobar')
!!(user && user.authenticate('foobar'))
!(user && user.authenticate('foobar'))
val = 1
!!(val==1)
(val==1)
!(val==1)
!(val)
val
!!(val)
!!(val.empty?)
!!(val.empty)
exit
pass = ""
pass.downcase
wzir
exit
